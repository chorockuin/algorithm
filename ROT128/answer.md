소스코드를 보면 너무 쉬우니, 소스코드는 보지 않기로 하고...
encfile이 png 파일을 암호화 한 것이라는 힌트는 사용하자.
png 파일의 구성부터 알아봐야겠지? png 파일은 다음과 같이 구성된다.

png 파일의 시그니처 8바이트(89 50 4E 47 0D 0A 1A 0A)
    89: 10진수로 바꾸면 137인데, ASCII 코드 범위를 벗어난 값으로, ASCII 코드로 시작되는 일반 텍스트가 아니라는 의미
    50 4E 47: ASCII 코드로 'P', 'N', 'G'
    0D 0A: 윈도우즈의 CRLF 문자
    1A: DOS의 EOF 문자
    0A: 유닉스의 LF 문자

png 파일의 데이터 청크들
    4바이트: 데이터 청크 길이
    4바이트: 데이터 청크 타입
        49 48 44 52: 'I', 'D', 'H', 'R' 이미지 헤더
        49 44 41 54: 'I', 'D', 'A', 'T' 이미지 데이터
        49 45 4E 44: 'I', 'E', 'N', 'D' 이미지 종료
        74 45 58 74: 't', 'E', 'X', 't' 압축되지 않은 텍스트 메타 데이터
        7A 54 58 74: 'z', 'T', 'X', 't' 압축된 텍스트 메타 데이터
        69 54 58 74: 'i', 'T', 'X', 't' UTF-8 텍스트 메타 데이터
    N바이트: 데이터 청크
    4바이트: CRC

이제 encfile의 처음 8바이트를 보자
09 D0 CE C7 8D 8A 9A 8A
9 208 206 199 141 138 154 138

png 파일의 헤더이므로 암호화되지 않았다면
89 50 4E 47 0D 0A 1A 0A 이어야 한다.
137 80 78 71 13 10 26 10

같은 길이로 암호화 되지 않을 수도 있겠지만, 일단 시작은 같은 길이로 가정해보고, 두 값이 관계가 있는지 따져본다.

9: 137 + 128 = 255를 초과하면 1바이트가 넘어가므로 256부터 다시 0으로 친다면, 즉, 257부터 1이라면 265 - 256 = 9
208: 80 + 128 = 208
206: 78 + 128 = 206
199: 71 + 128 = 199
141: 13 + 128 = 141
138: 10 + 128 = 138
154: 26 + 128 = 154
138: 10 + 128 = 138

즉 암호화 한 값은 png 각 바이트 값에 128을 더한 값이고, 만약 256을 넘으면 -256 해준 값이다.
즉, 다음과 같이 복호화 할 수 있다.

암호화 한 값이 128보다 크거나 같다면, 복호화한 값 = 암호화한 값 - 128
그렇지 않다면, 복호화한 값 = 암호화한 값 + 256 - 128

즉, 암호화한 파일을 한바이트씩 읽어서 위 로직을 적용하면 된다.

위와 같이 128을 더하고 256을 넘으면 256을 빼주는 관계도 말이 되지만,
128을 XOR 시켜주는(두 비트가 같으면 0, 다르면 1) 관계도 성립한다. 즉,

9(00001001) ^ 128(10000000) = 137(10001001), 137(10001001) ^ 128(10000000) = 9(00001001)
208(11010000) ^ 128(10000000) = 80(01010000), 80(01010000) ^ 128(10000000) = 208(11010000)
206(11001110) ^ 128(10000000) = 78(01001110), 78(01001110) ^ 128(10000000) = 206(11001110)
199(11000111) ^ 128(10000000) = 71(01000111), 71(01000111) ^ 128(10000000) = 199(11000111)
141(10001101) ^ 128(10000000) = 13(00001101), 13(00001101) ^ 128(10000000) = 141(10001101)
138(10001010) ^ 128(10000000) = 10(00001010), 10(00001010) ^ 128(10000000) = 138(10001010)
154(10011010) ^ 128(10000000) = 26(00011010), 26(00011010) ^ 128(10000000) = 154(10011010)
138(10001010) ^ 128(10000000) = 10(00001010), 10(00001010) ^ 128(10000000) = 138(10001010)

A ^ B = X ^ B = A 도 성립한다.
즉, XOR 연산은 같은 키(B 값)로 암호화/복호화 할 수 있다.

A   B   X
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0

X ^ B   A
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
0 ^ 0 = 0

X   A   B
0 ^ 1 = 1
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 0 = 0